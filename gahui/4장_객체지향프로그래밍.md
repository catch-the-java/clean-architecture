## 4장. 객체지향 프로그래밍
> 정리 링크 : https://gh402.tistory.com/57 [GHY 's TechBlog]


### 좋은 아키텍처를 만드는 일은 OO 설계 원칙을 이해하고 응용하는 데서 출발한다. 

</br>

#### OO(Object-Oriented)란?
- 캡슐화, 상속, 다형성 3가지를 적절히 조합한 것.

### 1) 캡슐화?
- OO를 정의하는 요소로 캡슐화를 언급하는 이유는 **데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공**하기 때문이다.
- C언어
- ex) point.h
```java
struct Point;
struct Point* makePoint(double x, double y);
double distance (struct Point *p1, struct Point *p2);
```
- ex) point.c
```java
#include "point.h"
#include <stdlib.h>
#include <math.h>

struct Point {
  double x,y;
};

struct Point* makepoint(double x, double y) {
  struct Point* p = malloc(sizeof(struct Point));
  p->x = x;
  p->y = y;
  return p;
}

double distance(struct Point* p1, struct Point* p2) {}
```
- -> Point의 구조체가 어떻게 구성되어 있는지 확인할 수 없으며, 함수만 사용할 수 있다. 
- -> 이것이 바로 완벽한 캡슐화
- 하지만, OO 언어는 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다.
    - 이유 : 자바와 C#에서 헤더와 구분체를 분리하는 방식을 모두 버렸기 때문.
    - OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.

</br>
</br>

### 2) 상속?
- 상속이란?
    - 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 것이다.
- 이전에 상속은 어떻게 구현했나? 
    - O에서 상속이 처음 나온 것은 아니고, C언어에서 "손수" 만들었다. 
    - 하지만, 직접 만들면서 다중 상속, 업캐스팅을 구현하기 어려웠다.
- 이런 점에서 OO언어는 새로운 개념을 만들지는 않았지만, 상당히 편리한 방식으로 상속을 구현할 수 있도록 제공했다고 볼 수 있다.

</br>
</br>

### 3) 다형성?
- 다형성이란?
    - 하나의 객체가 여러가지 타입을 가질 수 있는 것.(오버로딩, 오버라이딩, 함수형 인터페이스)

- 이전에 다형성은 어떻게 사용하고 있었나?
    - 위의 캡슐/상속과 마찬가지로 C언어에서 이미 STDOUT, STDIN 등과 같은 타입에 의존하여 사용하고 있었다.

- OO에서 다형성
    - 다형성은 함수를 가리키는 포인터를 응용했고, OO는 다형성을 좀 더 안전하고 편리하게 사용할 수 있도록 해준다.
    - C언어에서 함수의 포인터를 직접 사용하려고 한다면, 포인터를 초기화하고, 포인터를 통해 함수를 호출하는 관례를 지켜야 한다. 만약 프로그래머가 위의 작업을 망각하게 되면 버그를 찾아내기 힘들다.
    - OO는 이러한 관례를 없애주며, 실수할 위험이 없도록 만들었다. 
    - 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.


### 4) 다형성이 가진 힘
- 만약, 새로운 입출력장치가 생긴다고 하면 어떨까?
    - 우리가 진짜로 하고 싶었던 일은 "장치 독립성"으로 어떤 장치에서나 쉽게 사용할 수 있는 형태이다.
    - OO의 등장으로 "플러그인 아키텍처"를 적용할 수 있게 되었다.


### 5) 의존성 역전
- 다형성 매커니즘이 등장하기 전, 소프트웨어의 모습은?
    - 호출트리 : main함수 -> 고수준 함수 -> 중간 수준 함수 -> 저수준 함수
    - 소스코드의 의존성의 방향은 제어흐름을 따르게 된다.
- 다형성이 나타난 후에는?
    - 인터페이스를 통해 함수 호출이 되는데, 의존성의 방향은 제어흐름과 반대된다. 이를 의존성 역전이라고 한다.
    - OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
    - 또한, 의존성의 방향을 역전하고 싶다면, 인터페이스를 추가하면 된다.
    - 즉, 소스코드 의존성이 제어흐름의 방향과 일치하도록 제한되지 않는다.
    - 호출하는 모듈이든 아니면 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스코드 의존성을 원하는 방향으로 설정할 수 있다.
- 그렇다면, 어떻게 활용할 수 있는가?
    - 배포 독립성, 개발 독립성


6) 결론
- OO란?
    - 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
    - OO를 사용하면 플러그인 아키텍처를 구성할 수 있고, 모듈에 대해 독립성을 보장할 수 있다.
