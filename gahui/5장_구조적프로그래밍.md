## 5장. 구조적 프로그래밍
> 정리 링크 : https://gh402.tistory.com/57 [GHY 's TechBlog]

### 1) 탄생과정
- "데이크스트라"는 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실을 발견했다. (최소 집합은 순차, 분기, 반복 3가지로 표현할 수 있다는 것)
- 그렇기에 우리는 모두 구조적 프로그래머이며, 선택의 여지는 없다.
 
</br>
</br>

### 2) 기능적 분해
- 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 결국 모듈을 기능적으로 분해할 수 있음을 뜻한다.

 </br>
 </br>

### 3) 엄밀한 증명은 없다.
- 무언가가 올바른지를 입증할 때 사용하는 전략에 유클리드 방식 같이 수학적인 증명만 있는 것은 아니다.

- 상당히 성공한 또 다른 전략으로는 **과학적 방법** 이다.

#### 과학적 방법이란?
- 사실임을 증명하는 것이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.


</br>
</br> 


### 4) 테스트
- "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수 없다"
구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 

 
### 5) 결론
- 현재의 우리 모두는 구조적 프로그래머이며, 여기에 선택의 여지는 없다.
- 구조적 프로그래밍이 오늘날까지 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 이 능력 때문이다.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.

